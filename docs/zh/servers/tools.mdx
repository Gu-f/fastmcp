---
title: 工具
sidebarTitle: 工具
description: 将函数作为可执行功能暴露给您的 MCP 客户端。
icon: wrench
---

import { VersionBadge } from '/snippets/version-badge.mdx'

工具是核心构建块，允许您的 LLM 与外部系统交互、执行代码并访问不在其训练数据中的数据。在 FastMCP 中，工具是通过 MCP 协议暴露给 LLM 的 Python 函数。

## 什么是工具？

FastMCP 中的工具将常规 Python 函数转换为 LLM 在对话期间可以调用的功能。当 LLM 决定使用工具时：

1.  它发送一个基于工具架构的带参数的请求。
2.  FastMCP 根据您函数的签名验证这些参数。
3.  您的函数使用验证的输入执行。
4.  结果返回给 LLM，LLM 可以在其响应中使用它。

这允许 LLM 执行查询数据库、调用 API、进行计算或访问文件等任务——将其功能扩展到训练数据之外。

## 工具

### `@tool` 装饰器

创建工具就像用 `@mcp.tool` 装饰 Python 函数一样简单：

```python
from fastmcp import FastMCP

mcp = FastMCP(name="CalculatorServer")

@mcp.tool
def add(a: int, b: int) -> int:
    """将两个整数相加。"""
    return a + b
```

当此工具注册时，FastMCP 自动：
- 使用函数名称（`add`）作为工具名称。
- 使用函数的文档字符串（`将两个整数相加...`）作为工具描述。
- 基于函数的参数和类型注解生成输入架构。
- 处理参数验证和错误报告。

您定义 Python 函数的方式决定了工具如何为 LLM 客户端进行展示和执行行为。

<Tip>
不支持带有 `*args` 或 `**kwargs` 的函数作为工具。存在此限制是因为 FastMCP 需要为 MCP 协议生成完整的参数架构，这对于可变参数列表是不可能的。
</Tip>

#### 装饰器参数

虽然 FastMCP 从您的函数中推断名称和描述，但您可以使用 `@mcp.tool` 装饰器的参数来覆盖这些并添加额外的元数据：

```python
@mcp.tool(
    name="find_products",           # LLM 的自定义工具名称
    description="搜索产品目录，可选择类别过滤。", # 自定义描述
    tags={"catalog", "search"},      # 用于组织/过滤的可选标签
    meta={"version": "1.2", "author": "product-team"}  # 自定义元数据
)
def search_products_implementation(query: str, category: str | None = None) -> list[dict]:
    """内部函数描述（如果上面提供了描述则忽略）。"""
    # 实现...
    print(f"Searching for '{query}' in category '{category}'")
    return [{"id": 2, "name": "Another Product"}]
```

<Card icon="code" title="@tool 装饰器参数">
<ParamField body="name" type="str | None">
  设置通过 MCP 暴露的显式工具名称。如果未提供，则使用函数名称
</ParamField>

<ParamField body="description" type="str | None">
  提供通过 MCP 暴露的描述。如果设置，函数的文档字符串将被忽略
</ParamField>

<ParamField body="tags" type="set[str] | None">
  用于对工具进行分类的字符串集合。服务器和在某些情况下客户端可以使用这些来过滤或分组可用工具。
</ParamField>

<ParamField body="enabled" type="bool" default="True">
  启用或禁用工具的布尔值。更多信息请参阅[禁用工具](#disabling-tools)
</ParamField>

<ParamField body="exclude_args" type="list[str] | None">
  要从显示给 LLM 的工具架构中排除的参数名称列表。更多信息请参阅[排除参数](#excluding-arguments)
</ParamField>

<ParamField body="annotations" type="ToolAnnotations | dict | None">
    可选的 `ToolAnnotations` 对象或字典，用于添加关于工具的额外元数据。
  <Expandable title="ToolAnnotations 属性">
    <ParamField body="title" type="str | None">
      工具的人类可读标题。
    </ParamField>
    <ParamField body="readOnlyHint" type="bool | None">
      如果为 true，工具不会修改其环境。
    </ParamField>
    <ParamField body="destructiveHint" type="bool | None">
      如果为 true，工具可能对其环境执行破坏性更新。
    </ParamField>
    <ParamField body="idempotentHint" type="bool | None">
      如果为 true，使用相同参数重复调用工具对其环境不会产生额外影响。
    </ParamField>
    <ParamField body="openWorldHint" type="bool | None">
      如果为 true，此工具可能与外部实体的"开放世界"交互。如果为 false，工具的交互域是封闭的。
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="meta" type="dict[str, Any] | None">
  <VersionBadge version="2.11.0" />
  
  关于工具的可选元信息。此数据作为客户端工具对象的 `_meta` 字段传递给 MCP 客户端，可用于自定义元数据、版本控制或其他应用程序特定目的。
</ParamField>
</Card>


### 异步和同步工具

FastMCP 是一个异步优先的框架，无缝支持异步（`async def`）和同步（`def`）函数作为工具。对于 I/O 绑定操作，首选异步工具以保持服务器响应。

虽然同步工具在 FastMCP 中无缝工作，但它们在执行期间可能会阻塞事件循环。对于 CPU 密集型或可能阻塞的同步操作，请考虑替代策略。一种方法是使用 `anyio`（FastMCP 内部已经使用）将它们包装为异步函数，例如：

```python {1, 13}
import anyio
from fastmcp import FastMCP

mcp = FastMCP()

def cpu_intensive_task(data: str) -> str:
    # 一些可能阻塞事件循环的重型计算
    return processed_data

@mcp.tool
async def wrapped_cpu_task(data: str) -> str:
    """包装的 CPU 密集型任务以防止阻塞。"""
    return await anyio.to_thread.run_sync(cpu_intensive_task, data)
```

替代方法包括使用 `asyncio.get_event_loop().run_in_executor()` 或其他线程技术来管理阻塞操作，而不影响服务器响应性。例如，这里有一个使用 `asyncer` 库（不包含在 FastMCP 中）创建包装同步函数的装饰器的方法，感谢 [@hsheth2](https://github.com/jlowin/fastmcp/issues/864#issuecomment-3103678258)：

<CodeGroup>
```python 装饰器方法
import asyncer
import functools
from typing import Callable, ParamSpec, TypeVar, Awaitable

_P = ParamSpec("_P")
_R = TypeVar("_R")

def make_async_background(fn: Callable[_P, _R]) -> Callable[_P, Awaitable[_R]]:
    @functools.wraps(fn)
    async def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> _R:
        return await asyncer.asyncify(fn)(*args, **kwargs)

    return wrapper
```

```python 使用装饰器 {6}
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool()
@make_async_background
def my_tool() -> None:
    time.sleep(5)
```
</CodeGroup>


### 类型注解

参数的类型注解对于正确的工具功能至关重要。它们：
1. 向 LLM 通知每个参数的预期数据类型
2. 使 FastMCP 能够验证来自客户端的输入数据
3. 为 MCP 协议生成准确的 JSON 架构

对参数使用标准 Python 类型注解：

```python
@mcp.tool
def analyze_text(
    text: str,
    max_tokens: int = 100,
    language: str | None = None
) -> dict:
    """分析提供的文本。"""
    # 实现...
```

FastMCP 支持广泛的类型注解，包括所有 Pydantic 类型：

| 类型注解                 | 示例                          | 描述                               |
| :---------------------- | :---------------------------- | :---------------------------------- |
| 基本类型                | `int`, `float`, `str`, `bool` | 简单标量值 - 请参阅[内置类型](#built-in-types) |
| 二进制数据              | `bytes`                       | 二进制内容 - 请参阅[二进制数据](#binary-data) |
| 日期和时间              | `datetime`, `date`, `timedelta` | 日期和时间对象 - 请参阅[日期和时间类型](#date-and-time-types) |
| 集合类型                | `list[str]`, `dict[str, int]`, `set[int]` | 项目集合 - 请参阅[集合类型](#collection-types) |
| 可选类型                | `float \| None`, `Optional[float]`| 可能为空/省略的参数 - 请参阅[联合和可选类型](#union-and-optional-types) |
| 联合类型                | `str \| int`, `Union[str, int]`| 接受多种类型的参数 - 请参阅[联合和可选类型](#union-and-optional-types) |
| 受限类型                | `Literal["A", "B"]`, `Enum`   | 具有特定允许值的参数 - 请参阅[受限类型](#constrained-types) |
| 路径                    | `Path`                        | 文件系统路径 - 请参阅[路径](#paths) |
| UUID                    | `UUID`                        | 通用唯一标识符 - 请参阅[UUID](#uuids) |
| Pydantic 模型           | `UserData`                    | 复杂结构化数据 - 请参阅[Pydantic 模型](#pydantic-models) |

有关此处未列出的其他类型注解，请参阅下面的[参数类型](#parameter-types)部分，获取更详细的信息和示例。
### 参数元数据

您可以通过几种方式提供关于参数的额外元数据：

#### 简单字符串描述

<VersionBadge version="2.11.0" />

对于基本参数描述，您可以使用 `Annotated` 的便捷简写：

```python 
from typing import Annotated

@mcp.tool
def process_image(
    image_url: Annotated[str, "要处理的图像的 URL"],
    resize: Annotated[bool, "是否调整图像大小"] = False,
    width: Annotated[int, "目标宽度（像素）"] = 800,
    format: Annotated[str, "输出图像格式"] = "jpeg"
) -> dict:
    """处理图像并可选择调整大小。"""
    # 实现...
```

此简写语法等同于使用 `Field(description=...)`，但对于简单描述更简洁。

<Tip>
此简写语法仅适用于带有单个字符串描述的 `Annotated` 类型。
</Tip>

#### 使用 Field 的高级元数据

对于验证约束和高级元数据，使用 Pydantic 的 `Field` 类与 `Annotated`：

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def process_image(
    image_url: Annotated[str, Field(description="要处理的图像的 URL")],
    resize: Annotated[bool, Field(description="是否调整图像大小")] = False,
    width: Annotated[int, Field(description="目标宽度（像素）", ge=1, le=2000)] = 800,
    format: Annotated[
        Literal["jpeg", "png", "webp"], 
        Field(description="输出图像格式")
    ] = "jpeg"
) -> dict:
    """处理图像并可选择调整大小。"""
    # 实现...
```


您也可以将 Field 用作默认值，尽管首选 Annotated 方法：

```python
@mcp.tool
def search_database(
    query: str = Field(description="搜索查询字符串"),
    limit: int = Field(10, description="最大结果数量", ge=1, le=100)
) -> list:
    """使用提供的查询搜索数据库。"""
    # 实现...
```

Field 提供几个验证和文档功能：
- `description`：参数的人类可读解释（显示给 LLM）
- `ge`/`gt`/`le`/`lt`：大于/小于（或等于）约束
- `min_length`/`max_length`：字符串或集合长度约束
- `pattern`：字符串验证的正则表达式模式
- `default`：如果省略参数的默认值



### 可选参数

FastMCP 遵循 Python 的标准函数参数约定。没有默认值的参数是必需的，而有默认值的参数是可选的。

```python
@mcp.tool
def search_products(
    query: str,                   # 必需 - 无默认值
    max_results: int = 10,        # 可选 - 有默认值
    sort_by: str = "relevance",   # 可选 - 有默认值
    category: str | None = None   # 可选 - 可以为 None
) -> list[dict]:
    """搜索产品目录。"""
    # 实现...
```

在此示例中，LLM 必须提供 `query` 参数，而 `max_results`、`sort_by` 和 `category` 如果未明确提供将使用其默认值。


### 排除参数

<VersionBadge version="2.6.0" /> 

您可以从显示给 LLM 的工具架构中排除某些参数。这对于在运行时注入的参数（如 `state`、`user_id` 或凭据）很有用，这些参数不应暴露给 LLM 或客户端。只有具有默认值的参数才能被排除；尝试排除必需参数将引发错误。

示例：

```python
@mcp.tool(
    name="get_user_details",
    exclude_args=["user_id"]
)
def get_user_details(user_id: str = None) -> str:
    # user_id 将由服务器注入，不是由 LLM 提供
    ...
```

使用此配置，`user_id` 不会出现在工具的参数架构中，但仍可以在运行时由服务器或框架设置。

有关更复杂的工具转换，请参阅[转换工具](/zh/patterns/tool-transformation)。

### 禁用工具

<VersionBadge version="2.8.0" />

您可以通过启用或禁用工具来控制工具的可见性和可用性。这对于功能标记、维护或动态更改客户端可用的工具集很有用。禁用的工具不会出现在 `list_tools` 返回的可用工具列表中，尝试调用禁用的工具将导致"未知工具"错误，就像工具不存在一样。

默认情况下，所有工具都是启用的。您可以在创建时使用装饰器中的 `enabled` 参数禁用工具：

```python
@mcp.tool(enabled=False)
def maintenance_tool():
    """此工具目前正在维护中。"""
    return "This tool is disabled."
```

您也可以在创建工具后以编程方式切换工具状态：

```python
@mcp.tool
def dynamic_tool():
    return "I am a dynamic tool."

# 禁用和重新启用工具
dynamic_tool.disable()
dynamic_tool.enable()
```

### 返回值


FastMCP 工具可以以两种互补格式返回数据：**传统内容块**（如文本和图像）和**结构化输出**（机器可读的 JSON）。当您添加返回类型注解时，FastMCP 自动生成**输出架构**来验证结构化数据，并使客户端能够将结果反序列化为 Python 对象。

了解这三个概念如何协同工作：

- **返回值**：您的 Python 函数返回的内容（决定内容块和结构化数据）
- **结构化输出**：与传统内容一起发送的 JSON 数据，用于机器处理
- **输出架构**：描述和验证结构化输出格式的 JSON Schema 声明

以下部分详细解释每个概念。

#### Content Blocks

FastMCP automatically converts tool return values into appropriate MCP content blocks:

- **`str`**: Sent as `TextContent`
- **`bytes`**: Base64 encoded and sent as `BlobResourceContents` (within an `EmbeddedResource`)
- **`fastmcp.utilities.types.Image`**: Sent as `ImageContent`
- **`fastmcp.utilities.types.Audio`**: Sent as `AudioContent`
- **`fastmcp.utilities.types.File`**: Sent as base64-encoded `EmbeddedResource`
- **A list of any of the above**: Converts each item appropriately
- **`None`**: Results in an empty response

#### Structured Output

<VersionBadge version="2.10.0" />

The 6/18/2025 MCP spec update [introduced](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#structured-content) structured content, which is a new way to return data from tools. Structured content is a JSON object that is sent alongside traditional content. FastMCP automatically creates structured outputs alongside traditional content when your tool returns data that has a JSON object representation. This provides machine-readable JSON data that clients can deserialize back to Python objects.

**Automatic Structured Content Rules:**
- **Object-like results** (`dict`, Pydantic models, dataclasses) → Always become structured content (even without output schema)  
- **Non-object results** (`int`, `str`, `list`) → Only become structured content if there's an output schema to validate/serialize them
- **All results** → Always become traditional content blocks for backward compatibility

<Note>
This automatic behavior enables clients to receive machine-readable data alongside human-readable content without requiring explicit output schemas for object-like returns.
</Note>

##### Object-like Results (Automatic Structured Content)

<CodeGroup>
```python Dict Return (No Schema Needed)
@mcp.tool
def get_user_data(user_id: str) -> dict:
    """Get user data without type annotation."""
    return {"name": "Alice", "age": 30, "active": True}
```

```json Traditional Content
"{\n  \"name\": \"Alice\",\n  \"age\": 30,\n  \"active\": true\n}"
```

```json Structured Content (Automatic)
{
  "name": "Alice", 
  "age": 30,
  "active": true
}
```
</CodeGroup>

##### Non-object Results (Schema Required)

<CodeGroup>
```python Integer Return (No Schema)
@mcp.tool  
def calculate_sum(a: int, b: int):
    """Calculate sum without return annotation."""
    return a + b  # Returns 8
```

```json Traditional Content Only
"8"
```

```python Integer Return (With Schema)
@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """Calculate sum with return annotation."""  
    return a + b  # Returns 8
```

```json Traditional Content
"8"
```

```json Structured Content (From Schema)
{
  "result": 8
}
```
</CodeGroup>

##### Complex Type Example

<CodeGroup>
```python Tool Definition
from dataclasses import dataclass
from fastmcp import FastMCP

mcp = FastMCP()

@dataclass
class Person:
    name: str
    age: int
    email: str

@mcp.tool
def get_user_profile(user_id: str) -> Person:
    """Get a user's profile information."""
    return Person(name="Alice", age=30, email="alice@example.com")
```

```json Generated Output Schema
{
  "properties": {
    "name": {"title": "Name", "type": "string"},
    "age": {"title": "Age", "type": "integer"}, 
    "email": {"title": "Email", "type": "string"}
  },
  "required": ["name", "age", "email"],
  "title": "Person",
  "type": "object"
}
```

```json Structured Output
{
  "name": "Alice",
  "age": 30,
  "email": "alice@example.com"
}
```
</CodeGroup>

#### Output Schemas

<VersionBadge version="2.10.0" />

The 6/18/2025 MCP spec update [introduced](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#output-schema) output schemas, which are a new way to describe the expected output format of a tool. When an output schema is provided, the tool *must* return structured output that matches the schema.

When you add return type annotations to your functions, FastMCP automatically generates JSON schemas that describe the expected output format. These schemas help MCP clients understand and validate the structured data they receive.

##### Primitive Type Wrapping

For primitive return types (like `int`, `str`, `bool`), FastMCP automatically wraps the result under a `"result"` key to create valid structured output:

<CodeGroup>
```python Primitive Return Type
@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b
```

```json Generated Schema (Wrapped)
{
  "type": "object",
  "properties": {
    "result": {"type": "integer"}
  },
  "x-fastmcp-wrap-result": true
}
```

```json Structured Output
{
  "result": 8
}
```
</CodeGroup>

##### Manual Schema Control

You can override the automatically generated schema by providing a custom `output_schema`:

```python
@mcp.tool(output_schema={
    "type": "object", 
    "properties": {
        "data": {"type": "string"},
        "metadata": {"type": "object"}
    }
})
def custom_schema_tool() -> dict:
    """Tool with custom output schema."""
    return {"data": "Hello", "metadata": {"version": "1.0"}}
```

Schema generation works for most common types including basic types, collections, union types, Pydantic models, TypedDict structures, and dataclasses.

<Warning>
**Important Constraints**: 
- Output schemas must be object types (`"type": "object"`)
- If you provide an output schema, your tool **must** return structured output that matches it
- However, you can provide structured output without an output schema (using `ToolResult`)
</Warning>

#### Full Control with ToolResult

For complete control over both traditional content and structured output, return a `ToolResult` object:

```python
from fastmcp.tools.tool import ToolResult

@mcp.tool
def advanced_tool() -> ToolResult:
    """Tool with full control over output."""
    return ToolResult(
        content=[TextContent(text="Human-readable summary")],
        structured_content={"data": "value", "count": 42}
    )
```

When returning `ToolResult`:
- You control exactly what content and structured data is sent
- Output schemas are optional - structured content can be provided without a schema
- Clients receive both traditional content blocks and structured data

<Note>
If your return type annotation cannot be converted to a JSON schema (e.g., complex custom classes without Pydantic support), the output schema will be omitted but the tool will still function normally with traditional content.
</Note>

### Error Handling

<VersionBadge version="2.4.1" />

If your tool encounters an error, you can raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, custom exceptions, etc.) or a FastMCP `ToolError`.

By default, all exceptions (including their details) are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately.

If you want to mask internal error details for security reasons, you can:

1. Use the `mask_error_details=True` parameter when creating your `FastMCP` instance:
```python
mcp = FastMCP(name="SecureServer", mask_error_details=True)
```

2. Or use `ToolError` to explicitly control what error information is sent to clients:
```python
from fastmcp import FastMCP
from fastmcp.exceptions import ToolError

@mcp.tool
def divide(a: float, b: float) -> float:
    """Divide a by b."""

    if b == 0:
        # Error messages from ToolError are always sent to clients,
        # regardless of mask_error_details setting
        raise ToolError("Division by zero is not allowed.")
    
    # If mask_error_details=True, this message would be masked
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Both arguments must be numbers.")
        
    return a / b
```

When `mask_error_details=True`, only error messages from `ToolError` will include details, other exceptions will be converted to a generic message.

### Annotations

<VersionBadge version="2.2.7" />

FastMCP allows you to add specialized metadata to your tools through annotations. These annotations communicate how tools behave to client applications without consuming token context in LLM prompts.

Annotations serve several purposes in client applications:
- Adding user-friendly titles for display purposes
- Indicating whether tools modify data or systems
- Describing the safety profile of tools (destructive vs. non-destructive)
- Signaling if tools interact with external systems

You can add annotations to a tool using the `annotations` parameter in the `@mcp.tool` decorator:

```python
@mcp.tool(
    annotations={
        "title": "Calculate Sum",
        "readOnlyHint": True,
        "openWorldHint": False
    }
)
def calculate_sum(a: float, b: float) -> float:
    """Add two numbers together."""
    return a + b
```

FastMCP supports these standard annotations:

| Annotation | Type | Default | Purpose |
| :--------- | :--- | :------ | :------ |
| `title` | string | - | Display name for user interfaces |
| `readOnlyHint` | boolean | false | Indicates if the tool only reads without making changes |
| `destructiveHint` | boolean | true | For non-readonly tools, signals if changes are destructive |
| `idempotentHint` | boolean | false | Indicates if repeated identical calls have the same effect as a single call |
| `openWorldHint` | boolean | true | Specifies if the tool interacts with external systems |

Remember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and safety controls, but won't enforce security boundaries on their own. Always focus on making your annotations accurately represent what your tool actually does.

### Notifications

<VersionBadge version="2.9.1" />

FastMCP automatically sends `notifications/tools/list_changed` notifications to connected clients when tools are added, removed, enabled, or disabled. This allows clients to stay up-to-date with the current tool set without manually polling for changes.

```python
@mcp.tool
def example_tool() -> str:
    return "Hello!"

# These operations trigger notifications:
mcp.add_tool(example_tool)     # Sends tools/list_changed notification
example_tool.disable()         # Sends tools/list_changed notification  
example_tool.enable()          # Sends tools/list_changed notification
mcp.remove_tool("example_tool") # Sends tools/list_changed notification
```

Notifications are only sent when these operations occur within an active MCP request context (e.g., when called from within a tool or other MCP operation). Operations performed during server initialization do not trigger notifications.

Clients can handle these notifications using a [message handler](/zh/clients/messages) to automatically refresh their tool lists or update their interfaces.

## MCP Context

Tools can access MCP features like logging, reading resources, or reporting progress through the `Context` object. To use it, add a parameter to your tool function with the type hint `Context`.

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="ContextDemo")

@mcp.tool
async def process_data(data_uri: str, ctx: Context) -> dict:
    """Process data from a resource with progress reporting."""
    await ctx.info(f"Processing data from {data_uri}")
    
    # Read a resource
    resource = await ctx.read_resource(data_uri)
    data = resource[0].content if resource else ""
    
    # Report progress
    await ctx.report_progress(progress=50, total=100)
    
    # Example request to the client's LLM for help
    summary = await ctx.sample(f"Summarize this in 10 words: {data[:200]}")
    
    await ctx.report_progress(progress=100, total=100)
    return {
        "length": len(data),
        "summary": summary.text
    }
```

The Context object provides access to:

- **Logging**: `ctx.debug()`, `ctx.info()`, `ctx.warning()`, `ctx.error()`
- **Progress Reporting**: `ctx.report_progress(progress, total)`
- **Resource Access**: `ctx.read_resource(uri)`
- **LLM Sampling**: `ctx.sample(...)`
- **Request Information**: `ctx.request_id`, `ctx.client_id`

For full documentation on the Context object and all its capabilities, see the [Context documentation](/zh/servers/context).

## Parameter Types

FastMCP supports a wide variety of parameter types to give you flexibility when designing your tools.

FastMCP generally supports all types that Pydantic supports as fields, including all Pydantic custom types. This means you can use any type that can be validated and parsed by Pydantic in your tool parameters.

FastMCP supports **type coercion** when possible. This means that if a client sends data that doesn't match the expected type, FastMCP will attempt to convert it to the appropriate type. For example, if a client sends a string for a parameter annotated as `int`, FastMCP will attempt to convert it to an integer. If the conversion is not possible, FastMCP will return a validation error.

### Built-in Types

The most common parameter types are Python's built-in scalar types:

```python
@mcp.tool
def process_values(
    name: str,             # Text data
    count: int,            # Integer numbers
    amount: float,         # Floating point numbers
    enabled: bool          # Boolean values (True/False)
):
    """Process various value types."""
    # Implementation...
```

These types provide clear expectations to the LLM about what values are acceptable and allow FastMCP to validate inputs properly. Even if a client provides a string like "42", it will be coerced to an integer for parameters annotated as `int`.

### Date and Time Types

FastMCP supports various date and time types from the `datetime` module:

```python
from datetime import datetime, date, timedelta

@mcp.tool
def process_date_time(
    event_date: date,             # ISO format date string or date object
    event_time: datetime,         # ISO format datetime string or datetime object
    duration: timedelta = timedelta(hours=1)  # Integer seconds or timedelta
) -> str:
    """Process date and time information."""
    # Types are automatically converted from strings
    assert isinstance(event_date, date)  
    assert isinstance(event_time, datetime)
    assert isinstance(duration, timedelta)
    
    return f"Event on {event_date} at {event_time} for {duration}"
```

- `datetime` - Accepts ISO format strings (e.g., "2023-04-15T14:30:00")
- `date` - Accepts ISO format date strings (e.g., "2023-04-15")
- `timedelta` - Accepts integer seconds or timedelta objects

### Collection Types

FastMCP supports all standard Python collection types:

```python
@mcp.tool
def analyze_data(
    values: list[float],           # List of numbers
    properties: dict[str, str],    # Dictionary with string keys and values
    unique_ids: set[int],          # Set of unique integers
    coordinates: tuple[float, float],  # Tuple with fixed structure
    mixed_data: dict[str, list[int]] # Nested collections
):
    """Analyze collections of data."""
    # Implementation...
```

All collection types can be used as parameter annotations:
- `list[T]` - Ordered sequence of items
- `dict[K, V]` - Key-value mapping
- `set[T]` - Unordered collection of unique items
- `tuple[T1, T2, ...]` - Fixed-length sequence with potentially different types

Collection types can be nested and combined to represent complex data structures. JSON strings that match the expected structure will be automatically parsed and converted to the appropriate Python collection type.

### Union and Optional Types

For parameters that can accept multiple types or may be omitted:

```python
@mcp.tool
def flexible_search(
    query: str | int,              # Can be either string or integer
    filters: dict[str, str] | None = None,  # Optional dictionary
    sort_field: str | None = None  # Optional string
):
    """Search with flexible parameter types."""
    # Implementation...
```

Modern Python syntax (`str | int`) is preferred over older `Union[str, int]` forms. Similarly, `str | None` is preferred over `Optional[str]`.

### Constrained Types

When a parameter must be one of a predefined set of values, you can use either Literal types or Enums:

#### Literals

Literals constrain parameters to a specific set of values:

```python
from typing import Literal

@mcp.tool
def sort_data(
    data: list[float],
    order: Literal["ascending", "descending"] = "ascending",
    algorithm: Literal["quicksort", "mergesort", "heapsort"] = "quicksort"
):
    """Sort data using specific options."""
    # Implementation...
```

Literal types:
- Specify exact allowable values directly in the type annotation
- Help LLMs understand exactly which values are acceptable
- Provide input validation (errors for invalid values)
- Create clear schemas for clients

#### Enums

For more structured sets of constrained values, use Python's Enum class:

```python
from enum import Enum

class Color(Enum):
    RED = "red"
    GREEN = "green"
    BLUE = "blue"

@mcp.tool
def process_image(
    image_path: str, 
    color_filter: Color = Color.RED
):
    """Process an image with a color filter."""
    # Implementation...
    # color_filter will be a Color enum member
```

When using Enum types:
- Clients should provide the enum's value (e.g., "red"), not the enum member name (e.g., "RED")
- FastMCP automatically coerces the string value into the appropriate Enum object
- Your function receives the actual Enum member (e.g., `Color.RED`)
- Validation errors are raised for values not in the enum

### Binary Data

There are two approaches to handling binary data in tool parameters:

#### Bytes

```python
@mcp.tool
def process_binary(data: bytes):
    """Process binary data directly.
    
    The client can send a binary string, which will be 
    converted directly to bytes.
    """
    # Implementation using binary data
    data_length = len(data)
    # ...
```

When you annotate a parameter as `bytes`, FastMCP will:
- Convert raw strings directly to bytes
- Validate that the input can be properly represented as bytes

FastMCP does not automatically decode base64-encoded strings for bytes parameters. If you need to accept base64-encoded data, you should handle the decoding manually as shown below.

#### Base64-encoded strings

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def process_image_data(
    image_data: Annotated[str, Field(description="Base64-encoded image data")]
):
    """Process an image from base64-encoded string.
    
    The client is expected to provide base64-encoded data as a string.
    You'll need to decode it manually.
    """
    # Manual base64 decoding
    import base64
    binary_data = base64.b64decode(image_data)
    # Process binary_data...
```

This approach is recommended when you expect to receive base64-encoded binary data from clients.

### Paths

The `Path` type from the `pathlib` module can be used for file system paths:

```python
from pathlib import Path

@mcp.tool
def process_file(path: Path) -> str:
    """Process a file at the given path."""
    assert isinstance(path, Path)  # Path is properly converted
    return f"Processing file at {path}"
```

When a client sends a string path, FastMCP automatically converts it to a `Path` object.

### UUIDs

The `UUID` type from the `uuid` module can be used for unique identifiers:

```python
import uuid

@mcp.tool
def process_item(
    item_id: uuid.UUID  # String UUID or UUID object
) -> str:
    """Process an item with the given UUID."""
    assert isinstance(item_id, uuid.UUID)  # Properly converted to UUID
    return f"Processing item {item_id}"
```

When a client sends a string UUID (e.g., "123e4567-e89b-12d3-a456-426614174000"), FastMCP automatically converts it to a `UUID` object.

### Pydantic Models

For complex, structured data with nested fields and validation, use Pydantic models:

```python
from pydantic import BaseModel, Field
from typing import Optional

class User(BaseModel):
    username: str
    email: str = Field(description="User's email address")
    age: int | None = None
    is_active: bool = True

@mcp.tool
def create_user(user: User):
    """Create a new user in the system."""
    # The input is automatically validated against the User model
    # Even if provided as a JSON string or dict
    # Implementation...
```

Using Pydantic models provides:
- Clear, self-documenting structure for complex inputs
- Built-in data validation
- Automatic generation of detailed JSON schemas for the LLM
- Automatic conversion from dict/JSON input

Clients can provide data for Pydantic model parameters as either:
- A JSON object (string)
- A dictionary with the appropriate structure
- Nested parameters in the appropriate format

### Pydantic Fields

FastMCP supports robust parameter validation through Pydantic's `Field` class. This is especially useful to ensure that input values meet specific requirements beyond just their type.

Note that fields can be used *outside* Pydantic models to provide metadata and validation constraints. The preferred approach is using `Annotated` with `Field`:

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def analyze_metrics(
    # Numbers with range constraints
    count: Annotated[int, Field(ge=0, le=100)],         # 0 <= count <= 100
    ratio: Annotated[float, Field(gt=0, lt=1.0)],       # 0 < ratio < 1.0
    
    # String with pattern and length constraints
    user_id: Annotated[str, Field(
        pattern=r"^[A-Z]{2}\d{4}$",                     # Must match regex pattern
        description="User ID in format XX0000"
    )],
    
    # String with length constraints
    comment: Annotated[str, Field(min_length=3, max_length=500)] = "",
    
    # Numeric constraints
    factor: Annotated[int, Field(multiple_of=5)] = 10,  # Must be multiple of 5
):
    """Analyze metrics with validated parameters."""
    # Implementation...
```

You can also use `Field` as a default value, though the `Annotated` approach is preferred:

```python
@mcp.tool
def validate_data(
    # Value constraints
    age: int = Field(ge=0, lt=120),                     # 0 <= age < 120
    
    # String constraints
    email: str = Field(pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$"),  # Email pattern
    
    # Collection constraints
    tags: list[str] = Field(min_length=1, max_length=10)  # 1-10 tags
):
    """Process data with field validations."""
    # Implementation...
```

Common validation options include:

| Validation | Type | Description |
| :--------- | :--- | :---------- |
| `ge`, `gt` | Number | Greater than (or equal) constraint |
| `le`, `lt` | Number | Less than (or equal) constraint |
| `multiple_of` | Number | Value must be a multiple of this number |
| `min_length`, `max_length` | String, List, etc. | Length constraints |
| `pattern` | String | Regular expression pattern constraint |
| `description` | Any | Human-readable description (appears in schema) |

When a client sends invalid data, FastMCP will return a validation error explaining why the parameter failed validation.

## Server Behavior

### Duplicate Tools

<VersionBadge version="2.1.0" />

You can control how the FastMCP server behaves if you try to register multiple tools with the same name. This is configured using the `on_duplicate_tools` argument when creating the `FastMCP` instance.

```python
from fastmcp import FastMCP

mcp = FastMCP(
    name="StrictServer",
    # Configure behavior for duplicate tool names
    on_duplicate_tools="error"
)

@mcp.tool
def my_tool(): return "Version 1"

# This will now raise a ValueError because 'my_tool' already exists
# and on_duplicate_tools is set to "error".
# @mcp.tool
# def my_tool(): return "Version 2"
```

The duplicate behavior options are:

-   `"warn"` (default): Logs a warning and the new tool replaces the old one.
-   `"error"`: Raises a `ValueError`, preventing the duplicate registration.
-   `"replace"`: Silently replaces the existing tool with the new one.
-   `"ignore"`: Keeps the original tool and ignores the new registration attempt.

### Removing Tools

<VersionBadge version="2.3.4" />

You can dynamically remove tools from a server using the `remove_tool` method:

```python
from fastmcp import FastMCP

mcp = FastMCP(name="DynamicToolServer")

@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

mcp.remove_tool("calculate_sum")
```
